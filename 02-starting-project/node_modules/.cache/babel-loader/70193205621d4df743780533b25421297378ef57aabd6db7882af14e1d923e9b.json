{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\nvar _react = require('react');\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\n/**\n * Custom hook similar to useCallback, but for callbacks where the dependencies\n * change frequently. Ensures that references to state and props inside the\n * callback always get the latest values. Used to keep the `listen` and `stop`\n * functions in sync with the latest values of the `listening` and `supported`\n * state variables. See this issue for an example of why this is needed:\n *\n *   https://github.com/MikeyParton/react-speech-kit/issues/31\n *\n * Implementation taken from \"How to read an often-changing value from\n * useCallback?\" in the React hooks API reference:\n *\n *   https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n */\nvar useEventCallback = function useEventCallback(fn, dependencies) {\n  var ref = (0, _react.useRef)(function () {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n  (0, _react.useEffect)(function () {\n    ref.current = fn;\n  }, [fn].concat(_toConsumableArray(dependencies)));\n  return (0, _react.useCallback)(function (args) {\n    var fn = ref.current;\n    return fn(args);\n  }, [ref]);\n};\nvar useSpeechRecognition = function useSpeechRecognition() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _props$onEnd = props.onEnd,\n    onEnd = _props$onEnd === undefined ? function () {} : _props$onEnd,\n    _props$onResult = props.onResult,\n    onResult = _props$onResult === undefined ? function () {} : _props$onResult,\n    _props$onError = props.onError,\n    onError = _props$onError === undefined ? function () {} : _props$onError;\n  var recognition = (0, _react.useRef)(null);\n  var _useState = (0, _react.useState)(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    listening = _useState2[0],\n    setListening = _useState2[1];\n  var _useState3 = (0, _react.useState)(false),\n    _useState4 = _slicedToArray(_useState3, 2),\n    supported = _useState4[0],\n    setSupported = _useState4[1];\n  var processResult = function processResult(event) {\n    var transcript = Array.from(event.results).map(function (result) {\n      return result[0];\n    }).map(function (result) {\n      return result.transcript;\n    }).join('');\n    onResult(transcript);\n  };\n  var handleError = function handleError(event) {\n    if (event.error === 'not-allowed') {\n      recognition.current.onend = function () {};\n      setListening(false);\n    }\n    onError(event);\n  };\n  var listen = useEventCallback(function () {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (listening || !supported) return;\n    var _args$lang = args.lang,\n      lang = _args$lang === undefined ? '' : _args$lang,\n      _args$interimResults = args.interimResults,\n      interimResults = _args$interimResults === undefined ? true : _args$interimResults,\n      _args$continuous = args.continuous,\n      continuous = _args$continuous === undefined ? false : _args$continuous,\n      _args$maxAlternatives = args.maxAlternatives,\n      maxAlternatives = _args$maxAlternatives === undefined ? 1 : _args$maxAlternatives,\n      grammars = args.grammars;\n    setListening(true);\n    recognition.current.lang = lang;\n    recognition.current.interimResults = interimResults;\n    recognition.current.onresult = processResult;\n    recognition.current.onerror = handleError;\n    recognition.current.continuous = continuous;\n    recognition.current.maxAlternatives = maxAlternatives;\n    if (grammars) {\n      recognition.current.grammars = grammars;\n    }\n    // SpeechRecognition stops automatically after inactivity\n    // We want it to keep going until we tell it to stop\n    recognition.current.onend = function () {\n      return recognition.current.start();\n    };\n    recognition.current.start();\n  }, [listening, supported, recognition]);\n  var stop = useEventCallback(function () {\n    if (!listening || !supported) return;\n    recognition.current.onresult = function () {};\n    recognition.current.onend = function () {};\n    recognition.current.onerror = function () {};\n    setListening(false);\n    recognition.current.stop();\n    onEnd();\n  }, [listening, supported, recognition, onEnd]);\n  (0, _react.useEffect)(function () {\n    if (typeof window === 'undefined') return;\n    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    if (window.SpeechRecognition) {\n      setSupported(true);\n      recognition.current = new window.SpeechRecognition();\n    }\n  }, []);\n  return {\n    listen: listen,\n    listening: listening,\n    stop: stop,\n    supported: supported\n  };\n};\nexports.default = useSpeechRecognition;","map":{"version":3,"names":["Object","defineProperty","exports","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","length","err","Array","isArray","TypeError","_react","require","_toConsumableArray","arr2","from","useEventCallback","fn","dependencies","ref","useRef","Error","useEffect","current","concat","useCallback","args","useSpeechRecognition","props","arguments","_props$onEnd","onEnd","_props$onResult","onResult","_props$onError","onError","recognition","_useState","useState","_useState2","listening","setListening","_useState3","_useState4","supported","setSupported","processResult","event","transcript","results","map","result","join","handleError","error","onend","listen","_args$lang","lang","_args$interimResults","interimResults","_args$continuous","continuous","_args$maxAlternatives","maxAlternatives","grammars","onresult","onerror","start","stop","window","SpeechRecognition","webkitSpeechRecognition","default"],"sources":["/Users/yena/Documents/GitHub/React-demo/02-starting-project/node_modules/react-speech-kit/dist/useSpeechRecognition.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _react = require('react');\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n/**\n * Custom hook similar to useCallback, but for callbacks where the dependencies\n * change frequently. Ensures that references to state and props inside the\n * callback always get the latest values. Used to keep the `listen` and `stop`\n * functions in sync with the latest values of the `listening` and `supported`\n * state variables. See this issue for an example of why this is needed:\n *\n *   https://github.com/MikeyParton/react-speech-kit/issues/31\n *\n * Implementation taken from \"How to read an often-changing value from\n * useCallback?\" in the React hooks API reference:\n *\n *   https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n */\nvar useEventCallback = function useEventCallback(fn, dependencies) {\n  var ref = (0, _react.useRef)(function () {\n    throw new Error('Cannot call an event handler while rendering.');\n  });\n\n  (0, _react.useEffect)(function () {\n    ref.current = fn;\n  }, [fn].concat(_toConsumableArray(dependencies)));\n\n  return (0, _react.useCallback)(function (args) {\n    var fn = ref.current;\n    return fn(args);\n  }, [ref]);\n};\n\nvar useSpeechRecognition = function useSpeechRecognition() {\n  var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _props$onEnd = props.onEnd,\n      onEnd = _props$onEnd === undefined ? function () {} : _props$onEnd,\n      _props$onResult = props.onResult,\n      onResult = _props$onResult === undefined ? function () {} : _props$onResult,\n      _props$onError = props.onError,\n      onError = _props$onError === undefined ? function () {} : _props$onError;\n\n  var recognition = (0, _react.useRef)(null);\n\n  var _useState = (0, _react.useState)(false),\n      _useState2 = _slicedToArray(_useState, 2),\n      listening = _useState2[0],\n      setListening = _useState2[1];\n\n  var _useState3 = (0, _react.useState)(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      supported = _useState4[0],\n      setSupported = _useState4[1];\n\n  var processResult = function processResult(event) {\n    var transcript = Array.from(event.results).map(function (result) {\n      return result[0];\n    }).map(function (result) {\n      return result.transcript;\n    }).join('');\n\n    onResult(transcript);\n  };\n\n  var handleError = function handleError(event) {\n    if (event.error === 'not-allowed') {\n      recognition.current.onend = function () {};\n      setListening(false);\n    }\n    onError(event);\n  };\n\n  var listen = useEventCallback(function () {\n    var args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (listening || !supported) return;\n    var _args$lang = args.lang,\n        lang = _args$lang === undefined ? '' : _args$lang,\n        _args$interimResults = args.interimResults,\n        interimResults = _args$interimResults === undefined ? true : _args$interimResults,\n        _args$continuous = args.continuous,\n        continuous = _args$continuous === undefined ? false : _args$continuous,\n        _args$maxAlternatives = args.maxAlternatives,\n        maxAlternatives = _args$maxAlternatives === undefined ? 1 : _args$maxAlternatives,\n        grammars = args.grammars;\n\n    setListening(true);\n    recognition.current.lang = lang;\n    recognition.current.interimResults = interimResults;\n    recognition.current.onresult = processResult;\n    recognition.current.onerror = handleError;\n    recognition.current.continuous = continuous;\n    recognition.current.maxAlternatives = maxAlternatives;\n    if (grammars) {\n      recognition.current.grammars = grammars;\n    }\n    // SpeechRecognition stops automatically after inactivity\n    // We want it to keep going until we tell it to stop\n    recognition.current.onend = function () {\n      return recognition.current.start();\n    };\n    recognition.current.start();\n  }, [listening, supported, recognition]);\n\n  var stop = useEventCallback(function () {\n    if (!listening || !supported) return;\n    recognition.current.onresult = function () {};\n    recognition.current.onend = function () {};\n    recognition.current.onerror = function () {};\n    setListening(false);\n    recognition.current.stop();\n    onEnd();\n  }, [listening, supported, recognition, onEnd]);\n\n  (0, _react.useEffect)(function () {\n    if (typeof window === 'undefined') return;\n    window.SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;\n    if (window.SpeechRecognition) {\n      setSupported(true);\n      recognition.current = new window.SpeechRecognition();\n    }\n  }, []);\n\n  return {\n    listen: listen,\n    listening: listening,\n    stop: stop,\n    supported: supported\n  };\n};\n\nexports.default = useSpeechRecognition;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}